/*******************************************************************************
* タイトル:		エネミープログラム
* プログラム名:	enemy.cpp
* 作成者:		GP11A132 25 松本　賢治
* 作成日:		2022/07/07
*******************************************************************************/

/*******************************************************************************
* インクルードファイル
*******************************************************************************/
#include "main.h"
#include "player.h"
#include "field.h"
#include "enemy.h"
/*******************************************************************************
* マクロ定義
*******************************************************************************/


/*******************************************************************************
* 構造体定義
*******************************************************************************/


/*******************************************************************************
* プロトタイプ宣言(こんな関数を用意してありますよ宣言/関数の説明書)
*******************************************************************************/



/*******************************************************************************
* グローバル変数
*******************************************************************************/
ENEMY g_Enemy[ENEMY_MAX];	// PLAYER型でエネミー １体分


// エネミーの初期化処理
void InitEnemy(void)
{
	for (int i = 0; i < ENEMY_MAX; i++)
	{
		// 構造体の初期化


		//g_Enemy[i].name[0] = 'a';
		//g_Enemy[i].name[1] = 'b';

		g_Enemy[i].y = 12;		//ENEMY構造体の中のyに12を入れている　(y座標の初期位置)
		g_Enemy[i].x = 12;		//この.（ドット）のことをドット演算子という 意　〜の中の
							//構造体の中の変数（xやy等）のことをメンバー変数という

		g_Enemy[i].hp = g_Enemy[i].hp_max = 100;
		g_Enemy[i].atk = g_Enemy[i].atk_max = 30;




	}


	// g_Enemy[0].name = "ab";

	/*g_Enemy[0].name[0] = 'a';
	g_Enemy[0].name[1] = 'd';*/



	g_Enemy[0].y=10;		//Player構造体の中のyに2を入れている　(y座標の初期位置)
	g_Enemy[0].x =10;		//この.（ドット）のことをドット演算子という 意　〜の中の
						//構造体の中の変数（xやy等）のことをメンバー変数という
	g_Enemy[1].y = 11;		//ENEMY構造体の中のyに12を入れている　(y座標の初期位置)
	g_Enemy[1].x = 11;		//この.（ドット）のことをドット演算子という 意　〜の中の
						//構造体の中の変数（xやy等）のことをメンバー変数という
	g_Enemy[2].y = 12;		//Player構造体の中のyに2を入れている　(y座標の初期位置)
	g_Enemy[2].x = 12;		//この.（ドット）のことをドット演算子という 意　〜の中の
						//構造体の中の変数（xやy等）のことをメンバー変数という




	g_Enemy[0].hp = g_Enemy[0].hp_max = 150;
	g_Enemy[0].atk = g_Enemy[0].atk_max = 30;




	g_Enemy[1].hp = g_Enemy[1].hp_max = 190;
	g_Enemy[1].atk = g_Enemy[1].atk_max = 20;


}


// エネミーの終了処理
void UninitEnemy(void)
{


}


// エネミーの更新処理
void UpdateEnemy(void)
{
	for (int i = 0; i < ENEMY_MAX; i++)
	{

		

		// 動く前の座標を保存しておく（移動してぶつかった時はこの座標へ戻す為）
		
		g_Enemy[i].old_x = g_Enemy[i].x;
		g_Enemy[i].old_y = g_Enemy[i].y;

		int key = rand() % 8;	//8で割れば半分の確率で動かなくなる




		switch (key)
		{
		case 0:
		case 0x4b:	// ←
			g_Enemy[i].x--;
			break;

		case 1:
		case 0x4d:	// →
			g_Enemy[i].x++;
			break;

		case 2:
		case 0x48:	// ↑
			g_Enemy[i].y--;
			break;

		case 3:
		case 0x50:	// ↓
			g_Enemy[i].y++;
			break;

		default:	//4〜7はここ　動かずに終わる
			break;
		}

		// MAPとの当たり判定処理
		// 移動した先はNGな場所？
		int answer = CheckField(g_Enemy[i].y, g_Enemy[i].x);
		switch (answer)
		{
		case 1:	// 移動してはNGな場所だったので前の場所へ戻す
			g_Enemy[i].y = g_Enemy[i].old_y;
			g_Enemy[i].x = g_Enemy[i].old_x;
			break;

		default:
			break;
		}

	}

}


 //エネミーの描画処理
void DrawEnemy(void)
{
	for (int i = 0; i < ENEMY_MAX; i++)
	{


		// エネミーをMAPの指定座標へ書き込む
	//	SetField(g_Enemy[i].y, g_Enemy[i].x, 'E');
	}

}


// エネミーのアドレスを返す
ENEMY *GetEnemy(void)
{
	return &g_Enemy[0];
}


